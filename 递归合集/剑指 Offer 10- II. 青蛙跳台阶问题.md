# 剑指 Offer 10- II. 青蛙跳台阶问题
一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。

答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
```
示例 1：

输入：n = 2
输出：2
示例 2：

输入：n = 7
输出：21
提示：

0 <= n <= 100
```

# 方法：动态规划
```
class Solution {
    public int numWays(int n) {
        //递归，超时
        // if(n==0) return 1;
        // if(n==-1) return 0;
        
        // return (numWays(n-1)+numWays(n-2))%(1000000007);
        //动态规划：
        if(n==0) return 1;
        int[] dp = new int[n+1];
        dp[0] = 1;
        dp[1] = 1;
        for(int i=2;i<=n;i++){
            dp[i] = (dp[i-1]+dp[i-2])%1000000007;          
        }
        return dp[n];
    }
}
```
### PS : 为什么要模1000000007（跟我念，一，八个零，七）。参考https://www.liuchuo.net/archives/645

大数相乘，大数的排列组合等为什么要取模
1000000007是一个质数（素数），对质数取余能最大程度避免结果冲突/重复
int32位的最大值为2147483647，所以对于int32位来说1000000007足够大。
int64位的最大值为2^63-1，用最大值模1000000007的结果求平方，不会在int64中溢出。z
所以在大数相乘问题中，因为(a∗b)%c=((a%c)∗(b%c))%c，所以相乘时两边都对1000000007取模，再保存在int64里面不会溢出。
这道题为什么要取模，取模前后的值不就变了吗？
确实：取模前 f(43) = 701408733, f(44) = 1134903170, f(45) = 1836311903, 但是 f(46) > 2147483647结果就溢出了。

_____，取模后 f(43) = 701408733, f(44) = 134903163 , f(45) = 836311896, f(46) = 971215059没有溢出。

取模之后能够计算更多的情况，如 f(46)

这道题的测试答案与取模后的结果一致。

总结一下，这道题要模1000000007的根本原因是标准答案模了1000000007。不过大数情况下为了防止溢出，模1000000007是通用做法，原因见第一点。
